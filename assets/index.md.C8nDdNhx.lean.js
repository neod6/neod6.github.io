import{_ as e,c as t,o as l}from"./chunks/framework.DICQ8_im.js";const c=JSON.parse(`{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"编程竞赛","tagline":" USACO真题解析 Neo Ding","image":{"src":"/img/neo.jpg","alt":"neo"},"actions":[{"theme":"brand","text":"青铜组","link":"/bronze"},{"theme":"brand","text":"白银组","link":"/silver"},{"theme":"brand","text":"黄金组","link":"/gold"},{"theme":"alt","text":"项目目标","link":"/site"}]},"features":[{"title":"贪心算法⭐️","details":"做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用","link":"/al/greedy"},{"title":"单调队列","details":"用栈来维护一个单调队列.常见问题，一排山峰，能看见几个山峰，高的会把后面矮的挡住。一般需要从前到后扫描一次，再从后到前扫描一次","link":"/al/deque"},{"title":"双指针","details":"遍历两个单调数组，满足某个条件的一对数据，复杂度从双重遍历O(M*N)降至O(M+N)","link":"/al/two"},{"title":"PS前缀和⭐️","details":"从数组起点开始，截止当前元素，累加所有元素之和。易懂、有用。结合DP等算法，常常能把程序算法的时间复杂度降低一个O(N)","link":"/al/ps"},{"title":"DP动态规划⭐️","details":"通过把原问题分解为相对简单的子问题的方式来求解复杂问题.动态规划的应用非常广泛，包括但不限于：斐波那契数列、背包问题、资源分配问题、路径优化等","link":"/al/dp"},{"title":"Flood洪水填充算法⭐️","details":"将水倒入某个“低”单元格，水会流到所有相连通的“低单元格”中。它反映的是，某个单元格/节点和相邻单元格/节点的连通性/相同性。","link":"/al/flood"},{"title":"Dijkstar算法⭐️","details":"求非负边权图中，A点到B点最短路径, 算法复杂度O(NLogN)。利用最小堆来维护一个“最短路径”，每次从离出发点距离最近的节点，向下一步扩展。","link":"/al/dijkstar"},{"title":"RMQ区间极值","details":"区间和可以通过前缀和加减完成，区间极值不行。区间极值需要通过两个重叠区间极值的叠加来完成。通过预计算，来减少大量查询的时间。","link":"/al/rmq"},{"title":"MST最小生成树","details":"把图中所有节点连接起来的树，代价最小的一个。最小生成树，一般用加边法Kruskal's算法来实现。例如最小代价修路，把所有村庄连接起来","link":"/al/mst"}]},"headers":[],"relativePath":"index.md","filePath":"index.md"}`),i={name:"index.md"};function a(n,s,d,o,r,m){return l(),t("div")}const p=e(i,[["render",a]]);export{c as __pageData,p as default};
