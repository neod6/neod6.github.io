import{_ as i,c as e,o as l,a4 as r}from"./chunks/framework.Dk5wZOei.js";const p=JSON.parse('{"title":"CP Guide Contents","description":"","frontmatter":{},"headers":[],"relativePath":"usaco.md","filePath":"usaco.md"}'),m={name:"usaco.md"},t=r('<p>知识结构</p><p>参考 《Guide to Competitive Programming》 作者Antti Laaksonen</p><h1 id="cp-guide-contents" tabindex="-1">CP Guide Contents <a class="header-anchor" href="#cp-guide-contents" aria-label="Permalink to &quot;CP Guide Contents&quot;">​</a></h1><h2 id="_1-introduction" tabindex="-1">1. Introduction <a class="header-anchor" href="#_1-introduction" aria-label="Permalink to &quot;1. Introduction&quot;">​</a></h2><ul><li><strong>1.1 What is Competitive Programming?</strong><ul><li><em>1.1.1 Programming Contests</em></li><li><em>1.1.2 Tips for Practicing</em></li></ul></li><li><em>1.2 About This Book</em></li><li><em>1.3 CSES Problem Set</em></li><li><em>1.4 Other Resources</em></li></ul><h2 id="_2-programming-techniques" tabindex="-1">2. Programming Techniques <a class="header-anchor" href="#_2-programming-techniques" aria-label="Permalink to &quot;2. Programming Techniques&quot;">​</a></h2><ul><li><strong>2.1 Language Features</strong><ul><li><em>2.1.1 Input and Output</em></li><li><em>2.1.2 Working with Numbers</em></li><li><em>2.1.3 Shortening Code</em></li></ul></li><li><strong>2.2 Recursive Algorithms</strong><ul><li><em>2.2.1 Generating Subsets</em></li><li><em>2.2.2 Generating Permutations</em></li><li><em>2.2.3 Backtracking</em></li></ul></li><li><strong>2.3 Bit Manipulation</strong><ul><li><em>2.3.1 Bit Operations</em></li><li><em>2.3.2 Representing Sets</em></li></ul></li></ul><h2 id="_3-efficiency" tabindex="-1">3. Efficiency <a class="header-anchor" href="#_3-efficiency" aria-label="Permalink to &quot;3. Efficiency&quot;">​</a></h2><ul><li><strong>3.1 Time Complexity</strong><ul><li><em>3.1.1 Calculation Rules</em></li><li><em>3.1.2 Common Time Complexities</em></li><li><em>3.1.3 Estimating Efficiency</em></li><li><em>3.1.4 Formal Definitions</em></li></ul></li><li><em>3.2 Examples</em><ul><li><em>3.2.1 Maximum Subarray Sum</em></li><li><em>3.2.2 Two Queens Problem</em></li></ul></li></ul><h2 id="_4-sorting-and-searching" tabindex="-1">4. Sorting and Searching <a class="header-anchor" href="#_4-sorting-and-searching" aria-label="Permalink to &quot;4. Sorting and Searching&quot;">​</a></h2><ul><li><strong>4.1 Sorting Algorithms</strong><ul><li><em>4.1.1 Bubble Sort</em></li><li><em>4.1.2 Merge Sort</em></li><li><em>4.1.3 Sorting Lower Bound</em></li><li><em>4.1.4 Counting Sort</em></li><li><em>4.1.5 Sorting in Practice</em></li></ul></li><li><strong>4.2 Solving Problems by Sorting</strong><ul><li><em>4.2.1 Sweep Line Algorithms</em></li><li><em>4.2.2 Scheduling Events</em></li><li><em>4.2.3 Tasks and Deadlines</em></li></ul></li><li><strong>4.3 Binary Search</strong><ul><li><em>4.3.1 Implementing the Search</em></li><li><em>4.3.2 Finding Optimal Solutions</em></li></ul></li></ul><h2 id="_5-data-structures" tabindex="-1">5. Data Structures <a class="header-anchor" href="#_5-data-structures" aria-label="Permalink to &quot;5. Data Structures&quot;">​</a></h2><ul><li><strong>5.1 Dynamic Arrays</strong><ul><li><em>5.1.1 Vectors</em></li><li><em>5.1.2 Iterators and Ranges</em></li><li><em>5.1.3 Other Structures</em></li></ul></li><li><strong>5.2 Set Structures</strong><ul><li><em>5.2.1 Sets and Multisets</em></li><li><em>5.2.2 Maps</em></li><li><em>5.2.3 Priority Queues</em></li><li><em>5.2.4 Policy-Based Sets</em></li></ul></li><li><strong>5.3 Experiments</strong><ul><li><em>5.3.1 Set Versus Sorting</em></li><li><em>5.3.2 Map Versus Array</em></li><li><em>5.3.3 Priority Queue Versus Multiset</em></li></ul></li></ul><h2 id="_6-dynamic-programming" tabindex="-1">6. Dynamic Programming <a class="header-anchor" href="#_6-dynamic-programming" aria-label="Permalink to &quot;6. Dynamic Programming&quot;">​</a></h2><ul><li><strong>6.1 Basic Concepts</strong><ul><li><em>6.1.1 When Greedy Fails</em></li><li><em>6.1.2 Finding an Optimal Solution</em></li><li><em>6.1.3 Counting Solutions</em></li></ul></li><li><strong>6.2 Further Examples</strong><ul><li><em>6.2.1 Longest Increasing Subsequence</em></li><li><em>6.2.2 Paths in a Grid</em></li><li><em>6.2.3 Knapsack Problems</em></li><li><em>6.2.4 From Permutations to Subsets</em></li><li><em>6.2.5 Counting Tilings</em></li></ul></li></ul><h2 id="_7-graph-algorithms" tabindex="-1">7. Graph Algorithms <a class="header-anchor" href="#_7-graph-algorithms" aria-label="Permalink to &quot;7. Graph Algorithms&quot;">​</a></h2><ul><li><strong>7.1 Basics of Graphs</strong><ul><li><em>7.1.1 Graph Terminology</em></li><li><em>7.1.2 Graph Representation</em></li></ul></li><li><strong>7.2 Graph Traversal</strong><ul><li><em>7.2.1 Depth-First Search</em></li><li><em>7.2.2 Breadth-First Search</em></li><li><em>7.2.3 Applications</em></li></ul></li><li><strong>7.3 Shortest Paths</strong><ul><li><em>7.3.1 Bellman–Ford Algorithm</em></li><li><em>7.3.2 Dijkstra’s Algorithm</em></li><li><em>7.3.3 Floyd–Warshall Algorithm</em></li></ul></li><li><strong>7.4 Directed Acyclic Graphs</strong><ul><li><em>7.4.1 Topological Sorting</em></li><li><em>7.4.2 Dynamic Programming</em></li></ul></li><li><strong>7.5 Successor Graphs</strong><ul><li><em>7.5.1 Finding Successors</em></li><li><em>7.5.2 Cycle Detection</em></li></ul></li><li><strong>7.6 Minimum Spanning Trees</strong><ul><li><em>7.6.1 Kruskal’s Algorithm</em></li><li><em>7.6.2 Union-Find Structure</em></li><li><em>7.6.3 Prim’s Algorithm</em></li></ul></li></ul><h2 id="_8-algorithm-design-topics" tabindex="-1">8. Algorithm Design Topics <a class="header-anchor" href="#_8-algorithm-design-topics" aria-label="Permalink to &quot;8. Algorithm Design Topics&quot;">​</a></h2><ul><li><strong>8.1 Bit-Parallel Algorithms</strong><ul><li><em>8.1.1 Hamming Distances</em></li><li><em>8.1.2 Counting Subgrids</em></li><li><em>8.1.3 Reachability in Graphs</em></li></ul></li><li><strong>8.2 Amortized Analysis</strong><ul><li><em>8.2.1 Two Pointers Method</em></li><li><em>8.2.2 Nearest Smaller Elements</em></li><li><em>8.2.3 Sliding Window Minimum</em></li></ul></li><li><strong>8.3 Finding Minimum Values</strong><ul><li><em>8.3.1 Ternary Search</em></li><li><em>8.3.2 Convex Functions</em></li><li><em>8.3.3 Minimizing Sums</em></li></ul></li></ul><h2 id="_9-range-queries" tabindex="-1">9. Range Queries <a class="header-anchor" href="#_9-range-queries" aria-label="Permalink to &quot;9. Range Queries&quot;">​</a></h2><ul><li><strong>9.1 Queries on Static Arrays</strong><ul><li><em>9.1.1 Sum Queries</em></li><li><em>9.1.2 Minimum Queries</em></li></ul></li><li><strong>9.2 Tree Structures</strong><ul><li><em>9.2.1 Binary Indexed Trees</em></li><li><em>9.2.2 Segment Trees</em></li><li><em>9.2.3 Additional Techniques</em></li></ul></li></ul><h2 id="_10-tree-algorithms" tabindex="-1">10. Tree Algorithms <a class="header-anchor" href="#_10-tree-algorithms" aria-label="Permalink to &quot;10. Tree Algorithms&quot;">​</a></h2><ul><li><strong>10.1 Basic Techniques</strong><ul><li><em>10.1.1 Tree Traversal</em></li><li><em>10.1.2 Calculating Diameters</em></li><li><em>10.1.3 All Longest Paths</em></li></ul></li><li><strong>10.2 Tree Queries</strong><ul><li><em>10.2.1 Finding Ancestors</em></li><li><em>10.2.2 Subtrees and Paths</em></li><li><em>10.2.3 Lowest Common Ancestors</em></li><li><em>10.2.4 Merging Data Structures</em></li></ul></li><li><strong>10.3 Advanced Techniques</strong><ul><li><em>10.3.1 Centroid Decomposition</em></li><li><em>10.3.2 Heavy-Light Decomposition</em></li></ul></li></ul><h2 id="_11-mathematics" tabindex="-1">11. Mathematics <a class="header-anchor" href="#_11-mathematics" aria-label="Permalink to &quot;11. Mathematics&quot;">​</a></h2><ul><li><strong>11.1 Number Theory</strong><ul><li><em>11.1.1 Primes and Factors</em></li><li><em>11.1.2 Sieve of Eratosthenes</em></li><li><em>11.1.3 Euclid’s Algorithm</em></li><li><em>11.1.4 Modular Exponentiation</em></li><li><em>11.1.5 Euler’s Theorem</em></li><li><em>11.1.6 Solving Equations</em></li></ul></li><li><strong>11.2 Combinatorics</strong><ul><li><em>11.2.1 Binomial Coefficients</em></li><li><em>11.2.2 Catalan Numbers</em></li><li><em>11.2.3 Inclusion-Exclusion</em></li><li><em>11.2.4 Burnside’s Lemma</em></li><li><em>11.2.5 Cayley’s Formula</em></li></ul></li><li><strong>11.3 Matrices</strong><ul><li><em>11.3.1 Matrix Operations</em></li><li><em>11.3.2 Linear Recurrences</em></li><li><em>11.3.3 Graphs and Matrices</em></li><li><em>11.3.4 Gaussian Elimination</em></li></ul></li><li><strong>11.4 Probability</strong><ul><li><em>11.4.1 Working with Events</em></li><li><em>11.4.2 Random Variables</em></li><li><em>11.4.3 Markov Chains</em></li><li><em>11.4.4 Randomized Algorithms</em></li></ul></li><li><strong>11.5 Game Theory</strong><ul><li><em>11.5.1 Game States</em></li><li><em>11.5.2 Nim Game</em></li><li><em>11.5.3 Sprague–Grundy Theorem</em></li></ul></li></ul><h2 id="_12-advanced-graph-algorithms" tabindex="-1">12. Advanced Graph Algorithms <a class="header-anchor" href="#_12-advanced-graph-algorithms" aria-label="Permalink to &quot;12. Advanced Graph Algorithms&quot;">​</a></h2><ul><li><strong>12.1 Strong Connectivity</strong><ul><li><em>12.1.1 Kosaraju’s Algorithm</em></li><li><em>12.1.2 2SAT Problem</em></li></ul></li><li><strong>12.2 Complete Paths</strong><ul><li><em>12.2.1 Eulerian Paths</em></li><li><em>12.2.2 Hamiltonian Paths</em></li><li><em>12.2.3 Applications</em></li></ul></li><li><strong>12.3 Maximum Flows</strong><ul><li><em>12.3.1 Ford–Fulkerson Algorithm</em></li><li><em>12.3.2 Disjoint Paths</em></li><li><em>12.3.3 Maximum Matchings</em></li><li><em>12.3.4 Path Covers</em></li></ul></li><li><strong>12.4 Depth-First Search Trees</strong><ul><li><em>12.4.1 Biconnectivity</em></li><li><em>12.4.2 Eulerian Subgraphs</em></li></ul></li></ul><h2 id="_13-geometry" tabindex="-1">13. Geometry <a class="header-anchor" href="#_13-geometry" aria-label="Permalink to &quot;13. Geometry&quot;">​</a></h2><ul><li><strong>13.1 Geometric Techniques</strong><ul><li><em>13.1.1 Complex Numbers</em></li><li><em>13.1.2 Points and Lines</em></li><li><em>13.1.3 Polygon Area</em></li><li><em>13.1.4 Distance Functions</em></li></ul></li><li>**13.2 Sweep</li></ul>',29),a=[t];function n(o,s,u,g,h,c){return l(),e("div",null,a)}const S=i(m,[["render",n]]);export{p as __pageData,S as default};
