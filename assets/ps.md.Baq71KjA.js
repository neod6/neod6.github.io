import{_ as i,c as a,o as e,a4 as t}from"./chunks/framework.Dk5wZOei.js";const h=JSON.parse('{"title":"前缀和算法","description":"","frontmatter":{},"headers":[],"relativePath":"ps.md","filePath":"ps.md"}'),l={name:"ps.md"},p=t('<h1 id="前缀和算法" tabindex="-1">前缀和算法 <a class="header-anchor" href="#前缀和算法" aria-label="Permalink to &quot;前缀和算法&quot;">​</a></h1><p>原始数组 ：arr[k]</p><ol><li>一维前缀和： p[k]=p[k−1]+p[k] 应用：区间重叠计数</li><li>区间和： =p[k]−p[j] 从j+1到k的数字和</li><li>最大区间和 p[k]-min(p[:k]) 含自己，再求max</li><li>二维前缀和：自己+上+左-左上（减去重复） p[i][j]+p[i−1][j]+p[i][j−1]−p[i−1][j−1] 应用：矩阵重叠计数</li><li>子矩阵和：=自己-右上邻-左下邻+左上对角（加回重复） =P[i][j] - p[a-1][j] - p[i][b-1] + p[a-1][b-1] 左上角ab,右下角ij</li><li>最大子矩阵和：N2*M复杂度 应用：grid上有一堆牛，统计有k头牛的子矩阵数量</li><li>树形前缀和：DFS，每个节点求子树的和，原理一样。</li><li>前缀，不一定是和，可以加减乘除,任意操作。其实就是动态规划的转移方程</li></ol>',3),o=[p];function r(s,_,n,c,d,k){return e(),a("div",null,o)}const f=i(l,[["render",r]]);export{h as __pageData,f as default};
