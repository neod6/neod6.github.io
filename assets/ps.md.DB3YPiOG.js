import{_ as i,c as e,o as t,a4 as p,m as a}from"./chunks/framework.DICQ8_im.js";const f=JSON.parse('{"title":"前缀和算法","description":"","frontmatter":{},"headers":[],"relativePath":"ps.md","filePath":"ps.md"}'),l={name:"ps.md"},o=p('<h1 id="前缀和算法" tabindex="-1">前缀和算法 <a class="header-anchor" href="#前缀和算法" aria-label="Permalink to &quot;前缀和算法&quot;">​</a></h1><p>前缀和是一种很容易理解的算法，看名字就知道是什么意思。 但应用非常频繁，经常被用于一些比较复杂的问题的中间步骤。 结合DP等算法，常常能把程序算法的时间复杂度降低一个O(N)</p><p>原始数组 ：arr[k]</p><ol><li>一维前缀和： p[k]=p[k−1]+p[k] 应用：区间重叠计数</li><li>区间和： =p[k]−p[j] 从j+1到k的数字和</li><li>最大区间和 p[k]-min(p[:k]) 含自己，再求max</li><li>二维前缀和：自己+上+左-左上（减去重复） p[i][j]+p[i−1][j]+p[i][j−1]−p[i−1][j−1] 应用：矩阵重叠计数</li><li>子矩阵和：=自己-右上邻-左下邻+左上对角（加回重复） =P[i][j] - p[a-1][j] - p[i][b-1] + p[a-1][b-1] 左上角ab,右下角ij</li><li>最大子矩阵和：N2*M复杂度 应用：grid上有一堆牛，统计有k头牛的子矩阵数量</li><li>树形前缀和：DFS，每个节点求子树的和，原理一样。</li><li>前缀，不一定是和，可以加减乘除,任意操作。其实就是动态规划的转移方程</li></ol>',4),s=a("p",null,[a("a",{herf:"https://zhuanlan.zhihu.com/p/436526162?utm_id=0",target:"blank"},"扩展阅读")],-1),r=[o,s];function _(n,c,d,h,m,k){return t(),e("div",null,r)}const j=i(l,[["render",_]]);export{f as __pageData,j as default};
